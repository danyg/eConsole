/**
 * @overview 
 * @author Daniel Goberitz <daniel.goberitz@laviniainteractiva.com>
 */
var logger = require('logger'),
	socketIO = require('socket.io'),
	CLIArgs = require('CLIArgs'),
	GUI = require('GUI'),
	events = require('events')
;

CLIArgs.add('port', 'Puerto en el que se cargara el servidor Socket.IO, por default sera el 4040', true, 4040);
CLIArgs.bind('p', 'port');

module.exports = {
	eConsoles: [],
	io: null,
	clientsCache: {},

	publisher: new events.EventEmitter,
	on: function(){
		return this.publisher.on.apply(this.publisher, arguments);
	},
	emit: function(){
		return this.publisher.emit.apply(this.publisher, arguments);
	},

	open: function(){
		this.io = socketIO.listen( CLIArgs.has('port') || 4040 );
		var me = this;
		this.io.sockets.on('connection', function (socket) {
			me._newConnection(socket);
		});
	},
	
	getSocket: function(sID){
		return this.io.sockets.socket(sID);
	},
	
	getBroadcast: function(){
		return this.io.sockets.broadcast;
	},
	
	_newConnection: function(socket){
		var eConsole = false;
		var me = this;

		socket.on('clientInfo', function(data){
			if(data.eConsole){
				eConsole = true;
				me.addEClient(socket);
			}else{
				me.newClient(data, socket.id);
			}
		});

		socket.on('log', function(data){
			me.newRecord(socket.id, data);
		});

		socket.on('openedRecord', function(data){
			me.newRecord(socket.id, data);
		});
		
		socket.on('execReturn', function(data){
			me.newRecord(socket.id, data);
		});
		
		socket.on('eConsoleExec', function(data){
			if(eConsole){
				me.serverExec(data);
			}
		});

		socket.emit('welcome');

		socket.on('disconnect', function(data){
			me.outClient(socket.id);
			
			logger.log(socket.id + ' desconectado');
		});
	},
	
	addEClient: function(socket){
		this.eConsoles.push(socket);
		
		var sID;
		for(sID in this.clientsCache){
			if( this.clientsCache.hasOwnProperty(sID) ){
				
				socket.emit(
					'eConsoleExec', {
						cmd: 'newClient', 
						args: [this.clientsCache[sID], sID]
					}
				)
				
			}
		}
	},
	
	newClient: function(data, sID){
		if(GUI.hasGUI()){
			try{
				GUI.serverToGUI.newClient(data, sID);
			}catch(e){
				logger.error(e);
			}
		}
		
		this.clientsCache[sID] = data;

		this.eConsoleExec('newClient', Array.prototype.slice.call(arguments));
	},
	
	outClient: function(sID){
		delete(this.clientsCache[sID]);
		this.serverMessage(sID, 'DISCONNECT');
	},
	
	newRecord: function(sID, data){
		if(GUI.hasGUI()){
			try{
				GUI.serverToGUI.newRecord(sID, data);
			}catch(e){
				logger.error(e);
			}
		}
		this.eConsoleExec('newRecord', Array.prototype.slice.call(arguments));
	},
	
	serverMessage: function(sID, message){
		if(GUI.hasGUI()){
			try{
				GUI.serverToGUI.serverMessage(socket.id, 'DISCONNECT');
			}catch(e){
				logger.error(e);
			}
		}

		this.eConsoleExec('serverMessage', Array.prototype.slice.call(arguments));
	},
	
	/**
	 * @desc Metodo que se ejecuta para ejecutar un comando en una GUI Externa, 
	 * como si de una GUI Interna se tratase
	 */
	eConsoleExec: function(cmd, args){
		if(this.eConsoles.length > 0){
			this.eConsoles.forEach(function(socket){
				socket.emit(
					'eConsoleExec', {
						cmd: cmd, 
						args: args
					}
				);
			});
		}
	},

	/**
	 * @desc Metodo que se llama desde un eConsole GUI Externo, para ejecutar 
	 * un metodo en el objeto GUIToServer como si se tratara de un GUI Interno
	 */
	serverExec: function(data){
		GUItoServer = require('GUItoServer');
		try{
			GUItoServer[data.cmd].apply(GUItoServer, data.args);
		}catch(e){
			logger.error(e);
		}
	},
	
	close: function(){
		this.io.close();
	}
}